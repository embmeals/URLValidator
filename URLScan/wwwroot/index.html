<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL Validator</title>

    <!-- Bootstrap CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Vue.js & Axios -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.5/axios.min.js"></script>
</head>

<body class="container mt-4">
<div id="app">
    <h2 class="mb-3">URL Validator</h2>

    <div class="mb-3">
        <input type="file" class="form-control" @change="handleFileUpload">
    </div>

    <button class="btn btn-primary" @click="uploadUrls" :disabled="isProcessing">
        {{ isProcessing ? "Processing..." : "Validate URLs" }}
    </button>

    <!-- New summary row -->
    <div v-if="results.length" class="mt-3 mb-2">
        <div class="alert alert-info d-flex justify-content-between align-items-center">
            <span>
                <strong>Results:</strong> 
                {{ resultSummary.total }} URLs processed 
                ({{ resultSummary.indexed }} indexed, 
                <span class="text-danger">{{ resultSummary.noIndex }} noindex</span>, 
                {{ resultSummary.errors }} errors)
            </span>
            <span v-if="resultSummary.total !== uploadedCount" class="badge bg-warning text-dark">
                {{ uploadedCount - resultSummary.total }} URLs missing
            </span>
        </div>
    </div>

    <p v-if="errorMessage" class="text-danger mt-3">{{ errorMessage }}</p>

    <div class="table-responsive mt-4" v-if="paginatedResults.length">
        <table class="table table-bordered">
            <thead class="table-light">
            <tr>
                <th class="col-6">URL</th>
                <th class="col-2">Status</th>
                <th class="col-4">Details</th>
            </tr>
            </thead>
            <tbody>
            <tr v-for="(result, index) in paginatedResults" :key="index"
                :class="{ 
                    'table-danger': result.status === 'NoIndex Found' || result.status === 'Potential NoIndex',
                    'table-warning': result.status === 'Invalid URL' || result.status === '404 Not Found' || result.status === 'Server Error',
                    'table-success': result.status === 'Indexed'
                }">
                <td class="text-break text-truncate" style="max-width: 300px;">
                    <span :title="result.url">{{ result.url }}</span>
                </td>
                <td>{{ result.status }}</td>
                <td class="text-break">{{ result.details }}</td>
            </tr>
            </tbody>
        </table>
    </div>

    <nav v-if="totalPages > 1">
        <ul class="pagination justify-content-center">
            <li class="page-item" :class="{ 'disabled': currentPage === 1 }">
                <button class="page-link" @click="changePage(currentPage - 1)">Previous</button>
            </li>
            <li class="page-item" v-for="page in visiblePages" :key="page" :class="{ 'active': currentPage === page }">
                <button class="page-link" @click="changePage(page)">{{ page }}</button>
            </li>
            <li class="page-item" :class="{ 'disabled': currentPage === totalPages }">
                <button class="page-link" @click="changePage(currentPage + 1)">Next</button>
            </li>
        </ul>
    </nav>
</div>

<script>
    const { createApp } = Vue;

    createApp({
        data() {
            return {
                file: null,
                results: [],
                errorMessage: "",
                isProcessing: false,
                currentPage: 1,
                pageSize: 50,
                maxVisiblePages: 5,
                uploadedUrls: [], 
                uploadedCount: 0, 
                resultSummary: {  
                    total: 0,
                    noIndex: 0,
                    indexed: 0,
                    errors: 0
                }
            };
        },
        computed: {
            totalPages() {
                return Math.ceil(this.results.length / this.pageSize);
            },
            paginatedResults() {
                let start = (this.currentPage - 1) * this.pageSize;

                return this.results.slice(start, start + this.pageSize);
            },
            visiblePages() {
                let startPage = Math.max(1, this.currentPage - Math.floor(this.maxVisiblePages / 2));
                let endPage = Math.min(this.totalPages, startPage + this.maxVisiblePages - 1);

                return Array.from({ length: endPage - startPage + 1 }, (_, i) => startPage + i);
            }
        },
        methods: {
            changePage(page) {
                if (page >= 1 && page <= this.totalPages)
                    this.currentPage = page;
            },
            handleFileUpload(event) {
                const uploadedFile = event.target.files[0];

                if (!uploadedFile) {
                    this.errorMessage = "No file selected.";
                    return;
                }

                this.readFile(uploadedFile);
            },
            readFile(file) {
                const reader = new FileReader();

                reader.onload = (e) => {
                    this.processFile(file.name, e.target.result);
                };

                reader.readAsText(file);
            },
            processFile(filename, content) {
                const urls = this.extractUrls(filename, content);

                if (!urls.length) {
                    this.errorMessage = "File is empty or contains no valid URLs.";
                    return;
                }

                this.results = [];
                this.uploadUrls(urls);
            },
            extractUrls(filename, content) {
                const isCsv = filename.endsWith(".csv");

                const urls = [...new Set(content.split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(line => line)
                    .map(line => isCsv
                        ? this.extractUrlFromCsv(line)
                        : this.extractUrlFromText(line))
                    .filter(url => url)
                )];

                console.log(`Extracted ${urls.length} unique URLs from file`);

                return urls;
            },
            extractUrlFromCsv(line) {
                const url = line.split(",")[0]?.trim();

                return url && url.startsWith("http")
                    ? url
                    : null;
            },
            extractUrlFromText(line) {
                return line.startsWith("http")
                    ? line
                    : null;
            },
            uploadUrls(urls) {
                if (!urls.length) {
                    this.errorMessage = "No URLs provided.";
                    return;
                }

                this.errorMessage = "";
                this.isProcessing = true;
                this.results = [];
                this.currentPage = 1;

                this.uploadedUrls = [...urls];
                this.uploadedCount = urls.length;

                this.resultSummary = {
                    total: 0,
                    noIndex: 0,
                    indexed: 0,
                    errors: 0
                };

                const batchSize = 50;
                const batches = this.createBatches(urls, batchSize);
                console.log(`Created ${batches.length} batches from ${urls.length} URLs`);

                this.processBatches(batches);
            },
            createBatches(urls, batchSize) {
                const batches = [];
                for (let i = 0; i < urls.length; i += batchSize) {
                    batches.push(urls.slice(i, i + batchSize));
                }
                return batches;
            },
            processBatches(batches) {
                let completedBatches = 0;

                batches.forEach((batch, index) => {
                    setTimeout(() => {
                        this.sendBatch(batch, index, batches.length, () => {
                            completedBatches++;
                            if (completedBatches === batches.length) {
                                this.isProcessing = false;
                                this.finalizeResults();
                            }
                        });
                    }, index * 500);
                });
            },
            sendBatch(batch, batchIndex, totalBatches, onComplete) {
                console.log(`Sending batch ${batchIndex + 1}/${totalBatches} with ${batch.length} URLs`);

                axios.post('/api/UrlValidation/validate', batch)
                    .then(response => {
                        if (response.data && Array.isArray(response.data)) {
                            console.log(`Received ${response.data.length} results for batch ${batchIndex + 1}`);
                            this.results = [...this.results, ...response.data];
                        }
                    })
                    .catch(error => {
                        this.errorMessage = `Error: ${error.response ? error.response.data : "Server unreachable"}`;
                    })
                    .finally(() => {
                        onComplete();
                    });
            },
            finalizeResults() {
                const processedUrls = new Set(this.results.map(r => r.url.toLowerCase()));
                const missingUrls = this.uploadedUrls.filter(url =>
                    !processedUrls.has(url.toLowerCase())
                );

                console.log(`Results check: ${this.results.length} results from ${this.uploadedCount} uploaded URLs`);

                if (missingUrls.length > 0) {
                    console.log(`Missing ${missingUrls.length} URLs in results`);

                    const missingResults = missingUrls.map(url => ({
                        url: url,
                        status: 'Invalid URL',
                        details: 'URL was not processed by the server'
                    }));

                    this.results = [...this.results, ...missingResults];
                }

                this.updateResultSummary();

                if (this.results.length !== this.uploadedCount) {
                    this.errorMessage = `Warning: Only ${this.results.length} results returned from ${this.uploadedCount} URLs submitted.`;
                }
            },
            updateResultSummary() {
                this.resultSummary.total = this.results.length;
                this.resultSummary.noIndex = this.results.filter(r =>
                    r.status === 'NoIndex Found' || r.status === 'Potential NoIndex'
                ).length;
                this.resultSummary.indexed = this.results.filter(r =>
                    r.status === 'Indexed'
                ).length;
                this.resultSummary.errors = this.resultSummary.total -
                    this.resultSummary.indexed - this.resultSummary.noIndex;

                console.log(`Result summary: Total=${this.resultSummary.total}, `+
                    `Indexed=${this.resultSummary.indexed}, ` +
                    `NoIndex=${this.resultSummary.noIndex}, ` +
                    `Errors=${this.resultSummary.errors}`);
            }
        }
    }).mount('#app');
</script>

</body>
</html>