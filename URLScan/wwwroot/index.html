<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL Validator</title>

    <!-- Bootstrap CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Vue.js & Axios -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.5/axios.min.js"></script>
</head>

<body class="container mt-4">
<div id="app">
    <h2 class="mb-3">URL Validator</h2>

    <div class="mb-3">
        <input type="file" class="form-control" @change="handleFileUpload">
    </div>

    <button class="btn btn-primary" @click="uploadUrls" :disabled="isProcessing">
        {{ isProcessing ? "Processing..." : "Validate URLs" }}
    </button>

    <p v-if="errorMessage" class="text-danger mt-3">{{ errorMessage }}</p>

    <div class="table-responsive mt-4" v-if="paginatedResults.length">
        <table class="table table-bordered">
            <thead class="table-light">
            <tr>
                <th class="col-1">#</th>
                <th class="col-4">URL</th>
                <th class="col-2">Category</th>
                <th class="col-2">Status</th>
                <th class="col-4">Details</th>
            </tr>
            </thead>
            <tbody>
            <tr v-for="(result, index) in paginatedResults" :key="index"
                :class="{ 'table-danger': result.status === 'NoIndex Found' || result.status === 'Potential NoIndex' }">
                <td>{{ result.index }}</td>
                <td class="text-break text-truncate" style="max-width: 300px;">
                    <span :title="result.url">{{ result.url }}</span>
                </td>
                <td>{{ result.category }}</td>
                <td>{{ result.status }}</td>
                <td class="text-break">{{ result.details }}</td>
            </tr>
            </tbody>
        </table>
    </div>

    <nav v-if="totalPages > 1">
        <ul class="pagination justify-content-center">
            <li class="page-item" :class="{ 'disabled': currentPage === 1 }">
                <button class="page-link" @click="changePage(currentPage - 1)">Previous</button>
            </li>
            <li class="page-item" v-for="page in visiblePages" :key="page" :class="{ 'active': currentPage === page }">
                <button class="page-link" @click="changePage(page)">{{ page }}</button>
            </li>
            <li class="page-item" :class="{ 'disabled': currentPage === totalPages }">
                <button class="page-link" @click="changePage(currentPage + 1)">Next</button>
            </li>
        </ul>
    </nav>
</div>

<script>
    const { createApp } = Vue;

    createApp({
        data() {
            return {
                file: null,
                results: [],
                errorMessage: "",
                isProcessing: false,
                currentPage: 1,
                pageSize: 50,
                maxVisiblePages: 5
            };
        },
        computed: {
            totalPages() {
                return Math.ceil(this.results.length / this.pageSize);
            },
            paginatedResults() {
                var start = (this.currentPage - 1) * this.pageSize;
                
                return this.results.slice(start, start + this.pageSize);
            },
            visiblePages() {
                var startPage = Math.max(1, this.currentPage - Math.floor(this.maxVisiblePages / 2));
                var endPage = Math.min(this.totalPages, startPage + this.maxVisiblePages - 1);
                
                return Array.from({ length: endPage - startPage + 1 }, (_, i) => startPage + i);
            }
        },
        methods: {
            changePage(page) {
                var self = this;
                
                if (page >= 1 && page <= self.totalPages) 
                    self.currentPage = page;
            },
            handleFileUpload(event) {
                var self = this;
                var uploadedFile = event.target.files[0];

                if (!uploadedFile) {
                    self.errorMessage = "No file selected.";
                    return;
                }
                self.readFile(uploadedFile);
            },
            readFile(file) {
                var self = this;
                var reader = new FileReader();

                reader.onload = function (e) {
                    self.processFile(file.name, e.target.result);
                };

                reader.readAsText(file);
            },
            processFile(filename, content) {
                var self = this;
                var urls = self.extractUrls(filename, content);

                if (!urls.length) {
                    self.errorMessage = "File is empty or contains no valid URLs.";
                    return;
                }

                self.results = [];
                self.uploadUrls(urls);
            },
            extractUrls(filename, content) {
                var self = this;
                var isCsv = filename.endsWith(".csv");

                return [...new Set(content.split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(line => line)
                    .map(line => isCsv 
                        ? self.extractUrlFromCsv(line) 
                        : self.extractUrlFromText(line))
                    .filter(url => url)
                )];
            },
            extractUrlFromCsv(line) {
                var url = line.split(",")[0]?.trim();
                
                return url && url.startsWith("http") 
                    ? url 
                    : null;
            },
            extractUrlFromText(line) {
                return line.startsWith("http") 
                    ? line 
                    : null;
            },
            uploadUrls(urls) {
                var self = this;

                if (!urls.length) {
                    self.errorMessage = "No URLs provided.";
                    return;
                }

                self.errorMessage = "";
                self.isProcessing = true;
                self.results = [];
                self.currentPage = 1;

                var batchSize = 50;
                var batches = self.createBatches(urls, batchSize);
                
                self.processBatches(batches);
            },
            createBatches(urls, batchSize) {
                var batches = [];
                for (var i = 0; i < urls.length; i += batchSize) {
                    batches.push(urls.slice(i, i + batchSize));
                }
                return batches;
            },
            processBatches(batches) {
                var self = this;
                var completedBatches = 0;

                batches.forEach((batch, index) => {
                    setTimeout(() => {
                        self.sendBatch(batch, batches.length, () => {
                            completedBatches++;
                            if (completedBatches === batches.length) self.isProcessing = false;
                        });
                    }, index * 500);
                });
            },
            sendBatch(batch, totalBatches, onComplete) {
                var self = this;

                axios.post('/api/UrlValidation/validate', batch)
                    .then(response => {
                        let startIndex = self.results.length;
                        response.data.forEach((result, i) => {
                            result.index = startIndex + i + 1;
                        });

                        self.results = [...self.results, ...response.data];
                    })
                    .catch(error => {
                        self.errorMessage = `Error: ${error.response ? error.response.data : "Server unreachable"}`;
                    })
                    .finally(() => {
                        onComplete();
                    });
            }
        }
    }).mount('#app');
</script>

</body>
</html>